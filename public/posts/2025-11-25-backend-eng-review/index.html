<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="Why a review of backend engineering?
Like many people, I&rsquo;m trying to break into the AI / software industry. This is really tough in general because entry-level jobs in the field has decreased by 10% in the past couple years while mid to senior level jobs still steadily increased (Is Data Science Dying? - Marina Wyss - AI &amp; Machine Learning). Jobs like ML or AI engineer especially would require many years of experience. From stories I&rsquo;ve heard, it seems like either you get an internship which would lead to a full-time job, or you get an ML-adjacent job and transfer to an ML job in the same company.">  

  <title>
    
      üìù A Review Of Backend Engineer Jobs, Part. I
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/" />
  
  
  
  <link rel="stylesheet" href="/css/main.51652302d3a998bf7887aed5c2cf89141bbebdf45a2c8f87b0717a3cf4f51c4e53c694c328fb1de78c3a625a1c01f80745bf1f2f42c040647a245cbbb6c2d1d7.css" integrity="sha512-UWUjAtOpmL94h67Vws&#43;JFBu&#43;vfRaLI&#43;HsHF6PPT1HE5TxpTDKPsd54w6YlocAfgHRb8fL0LAQGR6JFy7tsLR1w==" />
  
</head>
<body a="auto">
        <main class="page-content" aria-label="Content">
            <div class="w">
                <div class="post-meta">
                    <a href="/">..</a>

                    <p>
                        <time datetime="2025-11-25 07:00:00 &#43;0800 &#43;0800">
                            2025-11-25
                        </time>
                    </p>
                </div>

<article>
    <h1>üìù A Review Of Backend Engineer Jobs, Part. I</h1>

    

    <h2 id="why-a-review-of-backend-engineering">Why a review of backend engineering?</h2>
<p>Like many people, I&rsquo;m trying to break into the AI / software industry. This is really tough in general because entry-level jobs in the field has decreased by 10% in the past couple years while mid to senior level jobs still steadily increased (<a href="https://www.youtube.com/watch?v=VbB9irtpoDc">Is Data Science Dying? - Marina Wyss - AI &amp; Machine Learning</a>). Jobs like ML or AI engineer especially would require many years of experience. From stories I&rsquo;ve heard, it seems like either you get an internship which would lead to a full-time job, or you get an ML-adjacent job and transfer to an ML job in the same company.</p>
<p>One of the best ML-adjacent job is naturally software engineer. Jobs titled with software engineer could be an umbralla term for a number of actual jobs. The job could focus on any of: frontend, backend, full-stack or even data engineering. Any of them are valid and interesting job functions. Here I focus on backend engineering just because I prefer it. It&rsquo;s more algorithmic and would touch on more challenging problems than simply interacting with database like software architecturing and database management.</p>
<h2 id="intro-to-this-series">Intro to this series</h2>
<p>This notebook uses a pre-existing Python library <a href="https://github.com/speedyapply/JobSpy">(github)</a> to scrape backend engineering jobs from major cities across the US, including most states. The choice of which city to scrape is arbitrary. In the end, the dataset was able to find 3060 jobs across the US. Each job is garanteed to have the following attributes:</p>
<ul>
<li>title</li>
<li>location</li>
<li>area</li>
<li>company</li>
<li>date posted</li>
<li>job type</li>
<li>is remote</li>
<li>job level</li>
<li>job function</li>
<li>description</li>
</ul>
<p>The city and state used to search for jobs is added as the <code>area</code> of jobs. The exact location of the actual jobs found could be different from the search term.</p>
<p>A few notes:</p>
<ul>
<li>I didn&rsquo;t write the scrapper so I don&rsquo;t know how it finds the jobs.</li>
<li>I&rsquo;ll attach in the end a list of cities covered in the dataset and the data aggregation pipeline.</li>
<li>All data are available on Kaggle: <a href="https://www.kaggle.com/datasets/tianyimasf/backend-engineer-jobs-us/data"><strong>view and download</strong></a></li>
</ul>
<h2 id="-exploratory-data-analysis">üîç Exploratory Data Analysis</h2>
<p>For this analysis, I only scraped jobs from LinkedIn. There&rsquo;re also plenty of jobs on Indeed and Google Jobs, but LinkedIn&rsquo;s data is relatively clean and there would exist a lot of overlaps.</p>
<p>I like to run <code>jobs.info()</code> to see what field exists, what is their data type and how many valid values they have.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#0f0"># EDA</span>
</span></span><span style="display:flex;"><span>jobs = pd.read_csv(root_dir+<span style="color:#87ceeb">&#34;jobs.csv&#34;</span>)
</span></span><span style="display:flex;"><span>jobs.info()
</span></span></code></pre></div><pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 3060 entries, 0 to 3059
Data columns (total 35 columns):
 #   Column                 Non-Null Count  Dtype  
---  ------                 --------------  -----  
 0   id                     3060 non-null   object 
 1   site                   3060 non-null   object 
 2   job_url                3060 non-null   object 
 3   job_url_direct         898 non-null    object 
 4   title                  3060 non-null   object 
 5   company                3060 non-null   object 
 6   location               2903 non-null   object 
 7   area                   3060 non-null   object 
 8   date_posted            2607 non-null   object 
 9   job_type               3060 non-null   object 
 10  salary_source          143 non-null    object 
 11  interval               143 non-null    object 
 12  min_amount             143 non-null    float64
 13  max_amount             143 non-null    float64
 14  currency               143 non-null    object 
 15  is_remote              3060 non-null   bool   
 16  job_level              3060 non-null   object 
 17  job_function           3059 non-null   object 
 18  listing_type           0 non-null      float64
 19  emails                 573 non-null    object 
 20  description            3060 non-null   object 
 21  company_industry       3060 non-null   object 
 22  company_url            3060 non-null   object 
 23  company_logo           3060 non-null   object 
 24  company_url_direct     0 non-null      float64
 25  company_addresses      0 non-null      float64
 26  company_num_employees  0 non-null      float64
 27  company_revenue        0 non-null      float64
 28  company_description    0 non-null      float64
 29  skills                 0 non-null      float64
 30  experience_range       0 non-null      float64
 31  company_rating         0 non-null      float64
 32  company_reviews_count  0 non-null      float64
 33  vacancy_count          0 non-null      float64
 34  work_from_home_type    0 non-null      float64
dtypes: bool(1), float64(14), object(20)
memory usage: 815.9+ KB
</code></pre>
<p>At first glance, the dataset has a lot of null values. However, on a closer look, a lot of the fields are not that important in the first palce. They&rsquo;re good to know if exists, but not necessary. Most of the fields that&rsquo;s expected to have values, like <code>title</code>, <code>company</code>, <code>description</code>, <code>company_industry</code> are all full.</p>
<details>
  <summary>Additional notes</summary>
  <div style="margin-top: 10px;">
    A couple of columns that&rsquo;s expected to have full values, like <code>location</code> and <code>date_posted</code>, lack part of the values. Since I didn&rsquo;t build the scraper, I don&rsquo;t know why the values are lacking. For a serious analysis, this could be crucial. Since most of the values are present and we should already know the range based on the search term, it seems fine for me to leave it as is. Sometimes null values like this could reveal crucial problems in the system if this analysis is for business purposes, but that&rsquo;s not the case here.
  </div>
</details>
<p>The other thing is a few fields don&rsquo;t have all the values but only some, like <code>job_url_direct</code>, <code>emails</code>, <code>salary_source</code>, <code>interval</code>, <code>min_amount</code>, <code>max_amount</code> and <code>currency</code>. Not all of these fields in this notebook will be analyzed, but it&rsquo;s interesting to see, for example, 898 out of the 3060 jobs have direct link to their job postings and 573 out of the 3060 jobs have emails. Only 143 out of all jobs have salary ranges, which we&rsquo;ll do some light analysis on in the next section &ldquo;Salary&rdquo;.</p>
<h3 id="map-of-jobs-counts-of-cities-across-the-us">Map of jobs counts of cities across the US</h3>
<p>When scraping jobs, I tried my best to expand the search to represent major cities in most states and include cities that are not traditionally represented in similar analysis. For example, Milwaukee, WI, Salt Lake City, UT, Birmingham, AL and Jackson, MS are all included. Even if the analysis is not applied to any specific city or state, all codes will be available as expandable code blocks and all data will be available by city or as a whole so that people can conduct analysis themselves if they want to. To show the state of backend engineering jobs in each of the cities, the review will follow the format of dividing each attribute by its geographical locations in each main section.</p>
<p>Below is the code to create a map of job counts by city.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#0f0"># import libraries</span>
</span></span><span style="display:flex;"><span><span style="color:#f00">import</span> plotly.express <span style="color:#f00">as</span> px
</span></span><span style="display:flex;"><span><span style="color:#f00">import</span> plotly.io <span style="color:#f00">as</span> pio
</span></span><span style="display:flex;"><span><span style="color:#f00">from</span> geopy.geocoders <span style="color:#f00">import</span> Nominatim
</span></span><span style="display:flex;"><span><span style="color:#f00">from</span> geopy.extra.rate_limiter <span style="color:#f00">import</span> RateLimiter
</span></span><span style="display:flex;"><span><span style="color:#f00">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># convert city, state to latitude, longitude</span>
</span></span><span style="display:flex;"><span>area_counts = jobs.groupby(<span style="color:#87ceeb">&#34;area&#34;</span>).size().reset_index(name=<span style="color:#87ceeb">&#34;count&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>geolocator = Nominatim(user_agent=<span style="color:#87ceeb">&#34;job_mapper&#34;</span>, timeout=<span style="color:#f60">10</span>)
</span></span><span style="display:flex;"><span>geocode = RateLimiter(geolocator.geocode, min_delay_seconds=<span style="color:#f60">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>lat_list = []
</span></span><span style="display:flex;"><span>lon_list = []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00">for</span> area in area_counts[<span style="color:#87ceeb">&#34;area&#34;</span>]:
</span></span><span style="display:flex;"><span>    loc = geocode(<span style="color:#87ceeb">f</span><span style="color:#87ceeb">&#34;</span><span style="color:#87ceeb">{</span>area<span style="color:#87ceeb">}</span><span style="color:#87ceeb">, USA&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#f00">if</span> loc:
</span></span><span style="display:flex;"><span>        lat_list.append(loc.latitude)
</span></span><span style="display:flex;"><span>        lon_list.append(loc.longitude)
</span></span><span style="display:flex;"><span>    <span style="color:#f00">else</span>:
</span></span><span style="display:flex;"><span>        lat_list.append(<span style="color:#f00">None</span>)
</span></span><span style="display:flex;"><span>        lon_list.append(<span style="color:#f00">None</span>)
</span></span><span style="display:flex;"><span>    time.sleep(<span style="color:#f60">1</span>)  <span style="color:#0f0"># required to avoid rate-limit</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>area_counts[<span style="color:#87ceeb">&#34;lat&#34;</span>] = lat_list
</span></span><span style="display:flex;"><span>area_counts[<span style="color:#87ceeb">&#34;lon&#34;</span>] = lon_list
</span></span></code></pre></div><p>This only needs to be run once. The following code plots the map of job counts by city in the US.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#0f0"># import saved file that map city, state to latitude, longitude</span>
</span></span><span style="display:flex;"><span>area_counts = pd.read_csv(root_dir+<span style="color:#87ceeb">&#34;area2latlon.csv&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fig = px.scatter_geo(
</span></span><span style="display:flex;"><span>    area_counts,
</span></span><span style="display:flex;"><span>    lat=<span style="color:#87ceeb">&#34;lat&#34;</span>,
</span></span><span style="display:flex;"><span>    lon=<span style="color:#87ceeb">&#34;lon&#34;</span>,
</span></span><span style="display:flex;"><span>    size=<span style="color:#87ceeb">&#34;count&#34;</span>,
</span></span><span style="display:flex;"><span>    hover_name=<span style="color:#87ceeb">&#34;area&#34;</span>,
</span></span><span style="display:flex;"><span>    hover_data={<span style="color:#87ceeb">&#34;count&#34;</span>: <span style="color:#f00">True</span>},
</span></span><span style="display:flex;"><span>    size_max=<span style="color:#f60">50</span>,
</span></span><span style="display:flex;"><span>    opacity=<span style="color:#f60">0.7</span>,
</span></span><span style="display:flex;"><span>    color=<span style="color:#87ceeb">&#34;count&#34;</span>,
</span></span><span style="display:flex;"><span>    color_continuous_scale=<span style="color:#87ceeb">&#34;Viridis&#34;</span>,
</span></span><span style="display:flex;"><span>    projection=<span style="color:#87ceeb">&#34;albers usa&#34;</span>,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Balanced background and black state lines</span>
</span></span><span style="display:flex;"><span>fig.update_layout(
</span></span><span style="display:flex;"><span>    title=<span style="color:#87ceeb">&#34;Jobs Counts By City Across The US&#34;</span>,
</span></span><span style="display:flex;"><span>    title_font_size=<span style="color:#f60">20</span>,
</span></span><span style="display:flex;"><span>    title_font_color=<span style="color:#87ceeb">&#34;#555555&#34;</span>,   <span style="color:#0f0"># grey title</span>
</span></span><span style="display:flex;"><span>    geo=dict(
</span></span><span style="display:flex;"><span>        scope=<span style="color:#87ceeb">&#34;usa&#34;</span>,
</span></span><span style="display:flex;"><span>        showland=<span style="color:#f00">True</span>,
</span></span><span style="display:flex;"><span>        landcolor=<span style="color:#87ceeb">&#34;#e0e0e0&#34;</span>,        <span style="color:#0f0"># medium-light gray</span>
</span></span><span style="display:flex;"><span>        lakecolor=<span style="color:#87ceeb">&#34;#d0e8ff&#34;</span>,        <span style="color:#0f0"># pale blue lakes</span>
</span></span><span style="display:flex;"><span>        showlakes=<span style="color:#f00">True</span>,
</span></span><span style="display:flex;"><span>        showcountries=<span style="color:#f00">True</span>,
</span></span><span style="display:flex;"><span>        countrycolor=<span style="color:#87ceeb">&#34;gray&#34;</span>,
</span></span><span style="display:flex;"><span>        showcoastlines=<span style="color:#f00">False</span>,
</span></span><span style="display:flex;"><span>        bgcolor=<span style="color:#87ceeb">&#34;#f5f5f5&#34;</span>,           <span style="color:#0f0"># soft gray background</span>
</span></span><span style="display:flex;"><span>        showsubunits=<span style="color:#f00">True</span>,
</span></span><span style="display:flex;"><span>        subunitcolor=<span style="color:#87ceeb">&#34;gray&#34;</span>,         <span style="color:#0f0"># black state lines</span>
</span></span><span style="display:flex;"><span>    ),
</span></span><span style="display:flex;"><span>    paper_bgcolor=<span style="color:#87ceeb">&#34;#f5f5f5&#34;</span>,         <span style="color:#0f0"># soft gray outside map</span>
</span></span><span style="display:flex;"><span>    font=dict(color=<span style="color:#87ceeb">&#34;black&#34;</span>),
</span></span><span style="display:flex;"><span>    margin={<span style="color:#87ceeb">&#34;r&#34;</span>:<span style="color:#f60">0</span>,<span style="color:#87ceeb">&#34;t&#34;</span>:<span style="color:#f60">50</span>,<span style="color:#87ceeb">&#34;l&#34;</span>:<span style="color:#f60">0</span>,<span style="color:#87ceeb">&#34;b&#34;</span>:<span style="color:#f60">0</span>},
</span></span><span style="display:flex;"><span>    height=<span style="color:#f60">500</span>,
</span></span><span style="display:flex;"><span>    width=<span style="color:#f60">1000</span>,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Optional: add city labels</span>
</span></span><span style="display:flex;"><span>fig.update_traces(text=area_counts[<span style="color:#87ceeb">&#34;area&#34;</span>], textposition=<span style="color:#87ceeb">&#34;top center&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fig.show()
</span></span></code></pre></div><p>It looks like a lot of code, but it&rsquo;s mostly just styling.</p>

<iframe src="/embeds/job_counts_by_city_us.html" width="710" height="410"></iframe>

<details>
  <summary>Additional notes</summary>
  <div style="margin-top: 10px;">
    It&rsquo;s black box why the scraper found exactly 140 jobs for all Boston, SF, San Jose, Seattle and Denver, but it&rsquo;s okay in my opinion because the numbers in general are correlated with our impression of which city has more tech jobs.
  </div>
</details>
<p>There&rsquo;re more jobs in commonly-known tech hubs like San Francisco and San Jose (= 140). But there&rsquo;re also a lot of backend engineering jobs in big cities like Baltimore, Washington D.C. and Chicago. It might be expected that Southern state have fewer jobs, but it&rsquo;s good to see that these following cities also have a decent amount of jobs:</p>
<ul>
<li>Atlanta, GA</li>
<li>Raleigh, NC</li>
<li>Charlotte, NC</li>
<li>Detroit, MI (80)</li>
<li>Minneapolis, MN (75)</li>
<li>Cincinnati, OH (70)</li>
<li>Phoenix, AZ (70)</li>
<li>Salt Lake City, UT (70)</li>
<li>Hartford, CT (70)</li>
<li>Pittsburgh, PA (69)</li>
</ul>
<p>Especially, Atlanta, GA has 120 jobs, and 90 and 89 jobs were found at Raleigh and Charlotte from North Carolina respectively. For comparison, Hartford, CT also have 70 jobs and Hartford is one of the small cities that has a lot of very well-paid tech jobs right above the NY state.</p>

<iframe src="/embeds/ratio_of_job_counts_by_city.html" width="710" height="510"></iframe>

<p>It seems from the US map of job counts by city that the majority of the jobs are from big tech cities. However, breaking it down in the second box/proportion graph, it&rsquo;s obvious that the number of jobs from big tech cities is clearly below the total number of jobs in the dataset. Moreover, there&rsquo;s a significant representation of cities from red states in the rest of the dataset, demonstrated by the city names in most of the boxes on the right side of the plot.</p>
<h2 id="-salary">üíµ Salary</h2>
<p>There&rsquo;re 143 jobs that have salary listed in total. Related fields are <code>salary_source</code>, <code>interval</code>, <code>min_amount</code> and <code>max_amount</code>. The field names don&rsquo;t tell us directly what the fields are, so the following blcok print the first value of each field.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>salary_source = jobs.salary_source.dropna().tolist()
</span></span><span style="display:flex;"><span>intervals = jobs.interval.dropna().tolist()
</span></span><span style="display:flex;"><span>min_amount = jobs.min_amount.dropna().tolist()
</span></span><span style="display:flex;"><span>max_amount = jobs.max_amount.dropna().tolist()
</span></span><span style="display:flex;"><span>print(<span style="color:#87ceeb">&#34;First value of each related field </span><span style="color:#87ceeb">\n</span><span style="color:#87ceeb">&#34;</span>+
</span></span><span style="display:flex;"><span><span style="color:#87ceeb">f</span><span style="color:#87ceeb">&#34;salary_source: </span><span style="color:#87ceeb">\&#34;</span><span style="color:#87ceeb">{</span>salary_source[<span style="color:#f60">0</span>]<span style="color:#87ceeb">}</span><span style="color:#87ceeb">\&#34;</span><span style="color:#87ceeb"> </span><span style="color:#87ceeb">\n</span><span style="color:#87ceeb">interval: </span><span style="color:#87ceeb">{</span>intervals[<span style="color:#f60">0</span>]<span style="color:#87ceeb">}</span><span style="color:#87ceeb"> </span><span style="color:#87ceeb">\n</span><span style="color:#87ceeb">min_amount: </span><span style="color:#87ceeb">{</span>min_amount[<span style="color:#f60">0</span>]<span style="color:#87ceeb">}</span><span style="color:#87ceeb"> </span><span style="color:#87ceeb">\n</span><span style="color:#87ceeb">max_amount: </span><span style="color:#87ceeb">{</span>max_amount[<span style="color:#f60">0</span>]<span style="color:#87ceeb">}</span><span style="color:#87ceeb">&#34;</span>)
</span></span></code></pre></div><pre><code>First value of each related field 
salary_source: &quot;description&quot; 
interval: yearly 
min_amount: 90000.0 
max_amount: 110000.0
</code></pre>
<p>From experience <code>salary_source</code> and <code>interval</code> would be the same for each of the 143 row. Just for scientific spirits, let&rsquo;s verify that.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>salary_source_unique = jobs.salary_source.dropna().unique().tolist()
</span></span><span style="display:flex;"><span>intervals_unique = jobs.interval.dropna().unique().tolist()
</span></span><span style="display:flex;"><span>print(<span style="color:#87ceeb">f</span><span style="color:#87ceeb">&#34;Salary source(s): </span><span style="color:#87ceeb">{</span>salary_source_unique<span style="color:#87ceeb">}</span><span style="color:#87ceeb"> </span><span style="color:#87ceeb">\n</span><span style="color:#87ceeb">Intervals: </span><span style="color:#87ceeb">{</span>intervals_unique<span style="color:#87ceeb">}</span><span style="color:#87ceeb">&#34;</span>)
</span></span></code></pre></div><pre><code>Salary source(s): ['description'] 
Intervals: ['yearly', 'hourly']
</code></pre>
<p>Turned out it&rsquo;s good we checked. When inspecting min salary amount and max salary amount, we&rsquo;ll check these seperately.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>min_amount_yearly = jobs[jobs.interval == <span style="color:#87ceeb">&#39;yearly&#39;</span>].min_amount.dropna().tolist()
</span></span><span style="display:flex;"><span>max_amount_yearly = jobs[jobs.interval == <span style="color:#87ceeb">&#39;yearly&#39;</span>].max_amount.dropna().tolist()
</span></span><span style="display:flex;"><span>min_amount_hourly = jobs[jobs.interval == <span style="color:#87ceeb">&#39;hourly&#39;</span>].min_amount.dropna().tolist()
</span></span><span style="display:flex;"><span>max_amount_hourly = jobs[jobs.interval == <span style="color:#87ceeb">&#39;hourly&#39;</span>].max_amount.dropna().tolist()
</span></span><span style="display:flex;"><span>print(<span style="color:#87ceeb">f</span><span style="color:#87ceeb">&#34;# of yearly salary instances: </span><span style="color:#87ceeb">{</span>len(min_amount_yearly)<span style="color:#87ceeb">}</span><span style="color:#87ceeb"> </span><span style="color:#87ceeb">\n</span><span style="color:#87ceeb"># of hourly salary instance(s): </span><span style="color:#87ceeb">{</span>len(min_amount_hourly)<span style="color:#87ceeb">}</span><span style="color:#87ceeb">&#34;</span>)
</span></span></code></pre></div><pre><code># of yearly salary instances: 140 
# of hourly salary instance(s): 3
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f00">for</span> i in range(<span style="color:#f60">3</span>):
</span></span><span style="display:flex;"><span>    print(<span style="color:#87ceeb">f</span><span style="color:#87ceeb">&#34;Hourly rate range </span><span style="color:#87ceeb">{</span>i+<span style="color:#f60">1</span><span style="color:#87ceeb">}</span><span style="color:#87ceeb">: $</span><span style="color:#87ceeb">{</span>min_amount_hourly[i]<span style="color:#87ceeb">}</span><span style="color:#87ceeb">/hr - $</span><span style="color:#87ceeb">{</span>max_amount_hourly[i]<span style="color:#87ceeb">}</span><span style="color:#87ceeb">/hr&#34;</span>)
</span></span></code></pre></div><pre><code>Hourly rate range 1: $30.0/hr - $33.0/hr
Hourly rate range 2: $75.0/hr - $80.0/hr
Hourly rate range 3: $40.0/hr - $45.0/hr
</code></pre>
<p>We can translate hourly rates to yearly rates assuming the job works 40hr/week and 4 weeks/month.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f00">for</span> i in range(<span style="color:#f60">3</span>):
</span></span><span style="display:flex;"><span>    min_amount_yearly.append(min_amount_hourly[i]*<span style="color:#f60">40</span>*<span style="color:#f60">4</span>*<span style="color:#f60">12</span>)
</span></span><span style="display:flex;"><span>    max_amount_yearly.append(max_amount_hourly[i]*<span style="color:#f60">40</span>*<span style="color:#f60">4</span>*<span style="color:#f60">12</span>)
</span></span></code></pre></div><p>So then we get the numerical lower and higher end of minimal and maximal amount of salaries.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>print(<span style="color:#87ceeb">f</span><span style="color:#87ceeb">&#34;Lower end of minimal amount of salary: $</span><span style="color:#87ceeb">{</span>min(min_amount_yearly)/<span style="color:#f60">1000</span><span style="color:#87ceeb">}</span><span style="color:#87ceeb">k </span><span style="color:#87ceeb">\n</span><span style="color:#87ceeb">&#34;</span> +
</span></span><span style="display:flex;"><span>      <span style="color:#87ceeb">f</span><span style="color:#87ceeb">&#34;Higher end of minimal amount of salary: $</span><span style="color:#87ceeb">{</span>max(min_amount_yearly)/<span style="color:#f60">1000</span><span style="color:#87ceeb">}</span><span style="color:#87ceeb">k&#34;</span>)
</span></span></code></pre></div><pre><code>Lower end of minimal amount of salary: $50.0k 
Higher end of minimal amount of salary: $300.0k
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>print(<span style="color:#87ceeb">f</span><span style="color:#87ceeb">&#34;Lower end of maximal amount of salary: $</span><span style="color:#87ceeb">{</span>min(max_amount_yearly)/<span style="color:#f60">1000</span><span style="color:#87ceeb">}</span><span style="color:#87ceeb">k </span><span style="color:#87ceeb">\n</span><span style="color:#87ceeb">&#34;</span> +
</span></span><span style="display:flex;"><span>      <span style="color:#87ceeb">f</span><span style="color:#87ceeb">&#34;Higher end of maximal amount of salary: $</span><span style="color:#87ceeb">{</span>max(max_amount_yearly)/<span style="color:#f60">1000</span><span style="color:#87ceeb">}</span><span style="color:#87ceeb">k&#34;</span>)
</span></span></code></pre></div><pre><code>Lower end of maximal amount of salary: $63.36k 
Higher end of maximal amount of salary: $405.0k
</code></pre>
<p>It seems sort of arbitrary what these number actually means, so in the next section we look at the distribution for all salaries and then create maps of stats by city again.</p>
<h3 id="distribution-of-salary-range">Distribution of Salary Range</h3>
<p>First we load the libraries.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f00">import</span> matplotlib.pyplot <span style="color:#f00">as</span> plt
</span></span><span style="display:flex;"><span><span style="color:#f00">import</span> logging
</span></span><span style="display:flex;"><span>logging.getLogger(<span style="color:#87ceeb">&#34;matplotlib.font_manager&#34;</span>).disabled = <span style="color:#f00">True</span>
</span></span></code></pre></div><p>The following create a styled graph of minimal and maximal salary distribution.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>y_min = [<span style="color:#f60">1</span>] * len(min_amount_yearly)
</span></span><span style="display:flex;"><span>y_max = [<span style="color:#f60">2</span>] * len(max_amount_yearly)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt.xkcd()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt.figure(figsize=(<span style="color:#f60">9</span>, <span style="color:#f60">4</span>))
</span></span><span style="display:flex;"><span>plt.scatter([x/<span style="color:#f60">1000</span> <span style="color:#f00">for</span> x in min_amount_yearly], y_min, s=<span style="color:#f60">200</span>, color=<span style="color:#87ceeb">&#39;#FFB347&#39;</span>, label=<span style="color:#87ceeb">&#39;List1&#39;</span>, marker=<span style="color:#87ceeb">&#39;o&#39;</span>, alpha=<span style="color:#f60">0.7</span>)
</span></span><span style="display:flex;"><span>plt.scatter([x/<span style="color:#f60">1000</span> <span style="color:#f00">for</span> x in max_amount_yearly], y_max, s=<span style="color:#f60">200</span>, color=<span style="color:#87ceeb">&#39;#6A5ACD&#39;</span>, label=<span style="color:#87ceeb">&#39;List2&#39;</span>, marker=<span style="color:#87ceeb">&#39;o&#39;</span>, alpha=<span style="color:#f60">0.7</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Customize axes</span>
</span></span><span style="display:flex;"><span>plt.xticks(range(<span style="color:#f60">0</span>, int(max(max_amount_yearly)/<span style="color:#f60">1000</span>), <span style="color:#f60">10</span>), rotation=<span style="color:#f60">60</span>)
</span></span><span style="display:flex;"><span>plt.yticks([<span style="color:#f60">1</span>,<span style="color:#f60">2</span>], [<span style="color:#87ceeb">&#39;min salary&#39;</span>, <span style="color:#87ceeb">&#39;max salary&#39;</span>], rotation=<span style="color:#f60">45</span>)
</span></span><span style="display:flex;"><span>plt.xlabel(<span style="color:#87ceeb">&#39;salary (k/yr)&#39;</span>)
</span></span><span style="display:flex;"><span>y_min = <span style="color:#f60">0.5</span>
</span></span><span style="display:flex;"><span>y_max = <span style="color:#f60">2.45</span>
</span></span><span style="display:flex;"><span>plt.ylim(y_min, y_max)
</span></span><span style="display:flex;"><span>plt.title(<span style="color:#87ceeb">&#39;Backend engineer salary range distribution&#39;</span>)
</span></span><span style="display:flex;"><span>plt.grid(axis=<span style="color:#87ceeb">&#39;x&#39;</span>, linestyle=<span style="color:#87ceeb">&#39;:&#39;</span>, linewidth=<span style="color:#f60">1.65</span>, color=<span style="color:#87ceeb">&#39;#333333&#39;</span>, alpha=<span style="color:#f60">0.7</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt.show()
</span></span></code></pre></div><p><img src="/images/salary-distribution.png" alt="salary distribution"></p>
<p>It feels like the lower end of most salary ranges between $50k - $210k and the higher end of most salary ranges from $65k to $300k. By my own job browsing experience, this is pretty accurate. Compared to most tech jobs, this actually seems a bit low (quite low). If you search for data scientist or ML Eng jobs, the higher end could easily go up to around 600k to 800k. However, I hope this reiew can show <strong>why in my opinion, backend engineering is a great first job for job seekers in this market and will likely open up further opportunities.</strong></p>
<p><strong>P.S.</strong> If you&rsquo;re wondering why the graph is all doodles it&rsquo;s because of this magical command <code>plt.xkcd()</code>. You don&rsquo;t have to download extra packages because it&rsquo;s included in <code>matplotlib</code> but you do have to suppress the font manager warnings using <code>logging.getLogger(&quot;matplotlib.font_manager&quot;).disabled = True</code>.</p>
<h3 id="median-minimal-and-maximal-yearly-salary-across-us-cities">Median minimal and maximal yearly salary across US cities</h3>
<p>The code for plotting the map is similar to the above and very long just because of styling, so it&rsquo;s skipped. But the data aggregation and manipulation code is shown below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#0f0"># Converting hourly rates to yearly rates</span>
</span></span><span style="display:flex;"><span>min_amount_yearly = jobs[jobs.interval == <span style="color:#87ceeb">&#39;yearly&#39;</span>].min_amount.dropna()
</span></span><span style="display:flex;"><span>max_amount_yearly = jobs[jobs.interval == <span style="color:#87ceeb">&#39;yearly&#39;</span>].max_amount.dropna()
</span></span><span style="display:flex;"><span>min_amount_hourly = jobs[jobs.interval == <span style="color:#87ceeb">&#39;hourly&#39;</span>].min_amount.dropna()
</span></span><span style="display:flex;"><span>max_amount_hourly = jobs[jobs.interval == <span style="color:#87ceeb">&#39;hourly&#39;</span>].max_amount.dropna()
</span></span><span style="display:flex;"><span>min_amount_hourly = min_amount_hourly * <span style="color:#f60">40</span> * <span style="color:#f60">4</span> * <span style="color:#f60">12</span>
</span></span><span style="display:flex;"><span>max_amount_hourly = max_amount_hourly * <span style="color:#f60">40</span> * <span style="color:#f60">4</span> * <span style="color:#f60">12</span>
</span></span><span style="display:flex;"><span>min_amount_yearly = pd.concat([min_amount_yearly, min_amount_hourly], ignore_index=<span style="color:#f00">True</span>)
</span></span><span style="display:flex;"><span>max_amount_yearly = pd.concat([max_amount_yearly, max_amount_hourly], ignore_index=<span style="color:#f00">True</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Data preparation: filtering cities that have jobs with salary</span>
</span></span><span style="display:flex;"><span>indices = jobs.min_amount.dropna().index.tolist()
</span></span><span style="display:flex;"><span>areas_with_valid_rates = jobs.loc[indices].area.tolist()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Data preparation: create the dataframe</span>
</span></span><span style="display:flex;"><span>data = {<span style="color:#87ceeb">&#34;area&#34;</span>: areas_with_valid_rates,
</span></span><span style="display:flex;"><span>       <span style="color:#87ceeb">&#34;min_amount&#34;</span>: min_amount_yearly.tolist(),
</span></span><span style="display:flex;"><span>       <span style="color:#87ceeb">&#34;max_amount&#34;</span>: max_amount_yearly.tolist()}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>df_salary_by_area = pd.DataFrame(data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Data aggregation: median minimal salary and job counts</span>
</span></span><span style="display:flex;"><span>df_area_min_salary_median = (
</span></span><span style="display:flex;"><span>    df_salary_by_area.groupby(<span style="color:#87ceeb">&#34;area&#34;</span>)
</span></span><span style="display:flex;"><span>    .agg(
</span></span><span style="display:flex;"><span>        min_amount_median=(<span style="color:#87ceeb">&#34;min_amount&#34;</span>, <span style="color:#87ceeb">&#34;median&#34;</span>),
</span></span><span style="display:flex;"><span>        count=(<span style="color:#87ceeb">&#34;min_amount&#34;</span>, <span style="color:#87ceeb">&#34;count&#34;</span>)   <span style="color:#0f0"># count rows per area</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    .reset_index()
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Data aggregation: median maximal salary and job counts</span>
</span></span><span style="display:flex;"><span>df_area_max_salary_median = (
</span></span><span style="display:flex;"><span>    df_salary_by_area.groupby(<span style="color:#87ceeb">&#34;area&#34;</span>)
</span></span><span style="display:flex;"><span>    .agg(
</span></span><span style="display:flex;"><span>        max_amount_median=(<span style="color:#87ceeb">&#34;max_amount&#34;</span>, <span style="color:#87ceeb">&#34;median&#34;</span>),
</span></span><span style="display:flex;"><span>        count=(<span style="color:#87ceeb">&#34;max_amount&#34;</span>, <span style="color:#87ceeb">&#34;count&#34;</span>)   <span style="color:#0f0"># same count (based on max_amount)</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    .reset_index()
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>area_counts = pd.read_csv(root_dir+<span style="color:#87ceeb">&#34;area2latlon.csv&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># --------Gets missing areas----------</span>
</span></span><span style="display:flex;"><span>df_area_min_salary_median = df_area_min_salary_median.merge(
</span></span><span style="display:flex;"><span>    area_counts[[<span style="color:#87ceeb">&#39;area&#39;</span>, <span style="color:#87ceeb">&#39;lat&#39;</span>, <span style="color:#87ceeb">&#39;lon&#39;</span>]],
</span></span><span style="display:flex;"><span>    on=<span style="color:#87ceeb">&#39;area&#39;</span>,
</span></span><span style="display:flex;"><span>    how=<span style="color:#87ceeb">&#39;left&#39;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Get sets of areas</span>
</span></span><span style="display:flex;"><span>all_areas = set(jobs[<span style="color:#87ceeb">&#34;area&#34;</span>])
</span></span><span style="display:flex;"><span>median_areas = set(df_area_min_salary_median[<span style="color:#87ceeb">&#34;area&#34;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Areas present in jobs but missing in median</span>
</span></span><span style="display:flex;"><span>missing_areas = list(all_areas - median_areas)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0"># Subset lat/lon for missing areas</span>
</span></span><span style="display:flex;"><span>missing_coords = area_counts[area_counts[<span style="color:#87ceeb">&#34;area&#34;</span>].isin(missing_areas)][[<span style="color:#87ceeb">&#39;area&#39;</span>, <span style="color:#87ceeb">&#39;lat&#39;</span>, <span style="color:#87ceeb">&#39;lon&#39;</span>]]
</span></span></code></pre></div><p>The resulted maps are shown below.</p>

<iframe src="/embeds/min_salary_map.html" width="710" height="410"></iframe>


<iframe src="/embeds/max_salary_map.html" width="710" height="410"></iframe>

<p>The first thing to notice is a few cities you wouldn&rsquo;t normally expect to have high median salaries have really high median salary. Hovering on the bubbles, the count tells you how many job in that city have salary listed. Most of these cities only have 1 to 3 jobs that have salary labels, a very small sample size that wouldn&rsquo;t be very representative. So the median salary of these cities shown on the map can&rsquo;t be fully trusted. A hypothesis could be that only companies who can offer good salary listed the number, but this needs to be verified.</p>
<p>The couple other things to notice: San Diego, CA has 5 jobs with a high median salary range of $172k/yr - $258k/yr. Next, the following cities have shown (diabolically) low median salaries.</p>
<ul>
<li>Salt Lake City, UT ($101k/yr - $108.5k/yr)</li>
<li>Milwaukee, WI ($77k/yr - $86k/yr)</li>
<li>Detroit, MI ($80k/yr - $110k/yr)</li>
<li>Indianapolis, IN ($70k/yr - $75k/yr)</li>
<li>Birmingham, AL ($90k/yr - $110k/yr)</li>
</ul>
<p>If you look through the bubbles, the median salaries in most cities on the map is $130k/yr - $195k/yr. So having salaries that range from around $80k/yr to barely $110k/yr shows that these cities might not have the most well-paid jobs.</p>
<p>Lastly, the cities that don&rsquo;t have jobs with salary listed is a mix of couple big cities and major cities from red states. This could mean that not having listed salary is common practice but needs further verification which we&rsquo;ll not dive into in this analysis.</p>
<hr>
<p>This concludes Part. I of my review of backend engineering job. Hope it&rsquo;s interesting in some ways.</p>

</article>

            </div>
        </main>
    </body></html>
